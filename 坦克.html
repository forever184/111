<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å¡é€šå¦å…‹å¤§æˆ˜ï¼ˆæ‰‹æœºæ¨ªå±ç‰ˆï¼‰</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">

    <!-- é…ç½®Tailwindè‡ªå®šä¹‰ä¸»é¢˜ -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#4F46E5', // ä¸»è‰²è°ƒï¼šç´«è‰²
                        secondary: '#EC4899', // è¾…åŠ©è‰²ï¼šç²‰è‰²
                        tankPlayer: '#22C55E', // ç©å®¶å¦å…‹ï¼šç»¿è‰²
                        tankEnemy: '#EF4444', // æ•Œäººå¦å…‹ï¼šçº¢è‰²
                        bullet: '#F59E0B', // å­å¼¹ï¼šæ©™è‰²
                        wall: '#78716C', // å¢™å£ï¼šç°è‰²
                        speedUp: '#3B82F6', // åŠ é€Ÿé“å…·ï¼šè“è‰²
                        heal: '#10B981', // å›è¡€é“å…·ï¼šç»¿è‰²
                    }
                }
            }
        }
    </script>

    <style type="text/tailwindcss">
        @layer utilities {
            .game-shadow {
                box-shadow: 0 0 15px rgba(0, 0, 0, 0.3);
            }
            .joystick-shadow {
                box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2);
            }
            .btn-pulse {
                animation: pulse 2s infinite;
            }
            .rotate-prompt {
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0,0,0,0.9);
                color: white;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                z-index: 9999;
                font-size: 1.5rem;
                text-align: center;
                padding: 2rem;
            }
            .rotate-icon {
                font-size: 4rem;
                margin-bottom: 1.5rem;
                animation: rotate 3s linear infinite;
            }
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        @keyframes rotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* æ ¸å¿ƒä¿®å¤ï¼šCSSè®¡ç®—å¿…é¡»ç”¨calc() */
        .game-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100vw;
            height: calc(100vw * 9 / 16); /* 16:9æ¯”ä¾‹ */
            max-width: calc(100vh * 16 / 9); /* ä¿®å¤ï¼šç”¨calc()åŒ…è£¹è®¡ç®—å¼ */
            max-height: 100vh;
            background: #111827;
        }

        /* æ¸¸æˆç”»å¸ƒæ ·å¼ */
        canvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            width: 100%;
            height: 100%;
        }

        /* åŸºç¡€æ ·å¼é‡ç½® */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: black;
            overflow: hidden; /* ç¦æ­¢é¡µé¢æ»šåŠ¨ */
            touch-action: none; /* ç¦ç”¨é»˜è®¤è§¦æ‘¸è¡Œä¸ºï¼ˆé˜²è¯¯è§¦å…³é”®ï¼‰ */
            height: 100vh;
            width: 100vw;
        }

        /* æ¨ªç«–å±é€‚é…ï¼šç«–å±åªæ˜¾ç¤ºæç¤ºï¼Œæ¨ªå±æ˜¾ç¤ºæ¸¸æˆ */
        @media (orientation: portrait) {
            .game-container {
                display: none;
            }
            .rotate-prompt {
                display: flex !important;
            }
        }

        @media (orientation: landscape) {
            .game-container {
                display: block;
            }
            .rotate-prompt {
                display: none !important;
            }
        }

        /* æ‰‹æœºæ§åˆ¶æŒ‰é’®ï¼šå¼ºåˆ¶æ˜¾ç¤ºï¼Œä½ç½®ä¼˜åŒ–ï¼ˆé˜²å³åˆ’è¯¯è§¦ï¼‰ */
        .mobile-controls {
            position: absolute;
            bottom: 25px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 30px; /* å·¦å³ç•™å‡ºå®‰å…¨è·ç¦»ï¼Œé¿å…è¾¹ç¼˜è¯¯è§¦ */
            z-index: 100;
        }

        .joystick-container {
            width: 80px;
            height: 80px;
            position: relative;
        }

        .fire-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: rgba(245, 158, 11, 0.9);
            color: white;
            font-size: 24px;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 15px rgba(245, 158, 11, 0.8);
            cursor: pointer;
        }

        .joystick-base {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: rgba(100, 100, 100, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .joystick {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: rgba(79, 70, 229, 0.9);
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(79, 70, 229, 0.8);
        }

        /* æ¸¸æˆç•Œé¢æ ·å¼ */
        .game-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        .game-title {
            font-size: 2rem;
            margin-bottom: 2rem;
            text-align: center;
        }

        .btn {
            padding: 12px 30px;
            margin: 10px;
            border: none;
            border-radius: 8px;
            background: #4F46E5;
            color: white;
            font-size: 1.1rem;
            cursor: pointer;
            transition: background 0.3s;
        }

        .btn:hover {
            background: #4338CA;
        }

        /* æ¸¸æˆçŠ¶æ€æ˜¾ç¤ºï¼ˆHUDï¼‰ */
        .hud {
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px;
            display: flex;
            justify-content: space-between;
            color: white;
            font-size: 1.2rem;
            z-index: 100;
            font-weight: bold;
        }

        .powerup-hint {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 3px 15px;
            border-radius: 15px;
            font-size: 1rem;
            display: none;
        }
    </style>
</head>
<body>
    <!-- æ¨ªå±æç¤ºï¼ˆç«–å±æ˜¾ç¤ºï¼Œæ¨ªå±éšè—ï¼‰ -->
    <div class="rotate-prompt">
        <i class="fa fa-mobile rotate-icon"></i>
        <p>è¯·å°†æ‰‹æœºæ¨ªå±æ¸¸ç©</p>
        <p class="text-sm mt-2 text-gray-300">æ¨ªå±åè‡ªåŠ¨æ˜¾ç¤ºæ¸¸æˆ</p>
    </div>

    <!-- æ¸¸æˆå®¹å™¨ï¼ˆ16:9æ¨ªå±æ¯”ä¾‹ï¼Œä¿®å¤CSSè®¡ç®—é”™è¯¯ï¼‰ -->
    <div class="game-container game-shadow rounded-lg overflow-hidden relative">
        <!-- æ¸¸æˆç”»å¸ƒ -->
        <canvas id="gameCanvas"></canvas>

        <!-- å¼€å§‹ç•Œé¢ -->
        <div id="startScreen" class="game-screen">
            <h1 class="game-title">å¡é€šå¦å…‹å¤§æˆ˜</h1>
            <button id="startBtn" class="btn btn-pulse">å¼€å§‹æ¸¸æˆ</button>
            <button id="howToBtn" class="btn">æ¸¸æˆè¯´æ˜</button>
        </div>

        <!-- æ¸¸æˆè¯´æ˜ç•Œé¢ -->
        <div id="howToScreen" class="game-screen" style="display: none;">
            <h1 class="game-title">æ¸¸æˆè¯´æ˜</h1>
            <div style="text-align: left; padding: 0 2rem; line-height: 2; margin-bottom: 1.5rem;">
                <p>ğŸ“± å·¦ä¾§æ‘‡æ†ï¼šæ‹–åŠ¨æ§åˆ¶å¦å…‹ç§»åŠ¨</p>
                <p>ğŸ”¥ å³ä¾§æŒ‰é’®ï¼šç‚¹å‡»å‘å°„å­å¼¹</p>
                <p>ğŸ’š ç»¿è‰²é“å…·ï¼šæ¢å¤1ç‚¹ç”Ÿå‘½å€¼</p>
                <p>ğŸ’™ è“è‰²é“å…·ï¼š5ç§’ç§»åŠ¨åŠ é€Ÿ</p>
                <p>ğŸ¯ æ¶ˆç­çº¢è‰²æ•Œäººå¦å…‹å¾—åˆ†</p>
                <p>â¤ï¸ é¿å…è¢«æ•Œäººå­å¼¹å‡»ä¸­</p>
            </div>
            <button id="backBtn" class="btn">è¿”å›</button>
        </div>

        <!-- æ¸¸æˆç»“æŸç•Œé¢ -->
        <div id="gameOverScreen" class="game-screen" style="display: none;">
            <h1 class="game-title">æ¸¸æˆç»“æŸ</h1>
            <p style="font-size: 1.5rem; margin-bottom: 2rem;">æœ€ç»ˆå¾—åˆ†ï¼š<span id="finalScore">0</span></p>
            <button id="restartBtn" class="btn">é‡æ–°å¼€å§‹</button>
            <button id="quitBtn" class="btn">é€€å‡ºæ¸¸æˆ</button>
        </div>

        <!-- æ‰‹æœºæ§åˆ¶åŒºï¼ˆå¼ºåˆ¶æ˜¾ç¤ºï¼Œé˜²è¯¯è§¦ä½ç½®ï¼‰ -->
        <div class="mobile-controls">
            <!-- è™šæ‹Ÿæ‘‡æ† -->
            <div class="joystick-container">
                <div class="joystick-base joystick-shadow">
                    <div id="joystick" class="joystick"></div>
                </div>
            </div>
            <!-- å‘å°„æŒ‰é’® -->
            <button id="fireBtn" class="fire-btn">
                <i class="fa fa-crosshairs"></i>
            </button>
        </div>

        <!-- æ¸¸æˆçŠ¶æ€æ˜¾ç¤º -->
        <div class="hud" id="hud" style="display: none;">
            <div>â¤ï¸ <span id="health">3</span></div>
            <div>â­ <span id="score">0</span></div>
        </div>

        <!-- é“å…·æç¤º -->
        <div class="powerup-hint" id="powerupHint">
            <i class="fa fa-bolt text-speedUp"></i> åŠ é€Ÿä¸­
        </div>
    </div>

    <script>
        // æ¸¸æˆæ ¸å¿ƒé…ç½®ï¼ˆä¼˜åŒ–ç§»åŠ¨è®¾å¤‡æ“ä½œä½“éªŒï¼‰
        const GAME_CONFIG = {
            playerSpeed: 1.8,    // ç©å®¶ç§»åŠ¨é€Ÿåº¦ï¼ˆé€‚ä¸­ï¼‰
            enemySpeed: 1.0,     // æ•Œäººç§»åŠ¨é€Ÿåº¦ï¼ˆè¾ƒæ…¢ï¼Œé™ä½éš¾åº¦ï¼‰
            bulletSpeed: 6,      // å­å¼¹é€Ÿåº¦ï¼ˆè¾ƒå¿«ï¼Œæå‡çˆ½æ„Ÿï¼‰
            tankSize: 32,        // å¦å…‹å°ºå¯¸ï¼ˆæ˜æ˜¾ï¼Œæ˜“æ“ä½œï¼‰
            bulletSize: 8,       // å­å¼¹å°ºå¯¸ï¼ˆæ¸…æ™°ï¼Œæ˜“èº²é¿ï¼‰
            obstacleSize: 32,    // éšœç¢ç‰©å°ºå¯¸
            powerUpSize: 24,     // é“å…·å°ºå¯¸
            enemySpawnInterval: 3500,  // æ•Œäººç”Ÿæˆé—´éš”ï¼ˆ3.5ç§’ï¼Œä¸æ‹¥æŒ¤ï¼‰
            powerUpSpawnInterval: 8000, // é“å…·ç”Ÿæˆé—´éš”ï¼ˆ8ç§’ï¼‰
            maxEnemies: 4,       // æœ€å¤§æ•Œäººæ•°é‡ï¼ˆ4ä¸ªï¼Œé™ä½éš¾åº¦ï¼‰
            playerMaxHealth: 3,  // ç©å®¶åˆå§‹ç”Ÿå‘½å€¼
            powerUpDuration: 5000 // é“å…·æ•ˆæœæŒç»­æ—¶é—´ï¼ˆ5ç§’ï¼‰
        };

        // æ¸¸æˆå…¨å±€çŠ¶æ€
        let gameState = 'start'; // start: å¼€å§‹ç•Œé¢, playing: æ¸¸æˆä¸­, gameOver: æ¸¸æˆç»“æŸ
        let canvas, ctx;
        let player = null;
        let enemies = [];
        let bullets = [];
        let obstacles = [];
        let powerUps = [];
        let score = 0;
        let enemySpawnTimer = 0;
        let powerUpSpawnTimer = 0;

        // æ§åˆ¶çŠ¶æ€ï¼ˆé”®ç›˜+è§¦æ‘¸ï¼‰
        const keyState = { up: false, down: false, left: false, right: false, fire: false };
        const joystickState = {
            active: false,  // æ˜¯å¦æ­£åœ¨æ‹–åŠ¨æ‘‡æ†
            x: 0,           // æ‘‡æ†ç›¸å¯¹åŸºå‡†ç‚¹Xåç§»
            y: 0,           // æ‘‡æ†ç›¸å¯¹åŸºå‡†ç‚¹Yåç§»
            baseX: 0,       // æ‘‡æ†åŸºå‡†ç‚¹Xåæ ‡ï¼ˆè§¦æ‘¸å¼€å§‹æ—¶çš„ä¸­å¿ƒï¼‰
            baseY: 0        // æ‘‡æ†åŸºå‡†ç‚¹Yåæ ‡
        };
        let isMobileFire = false; // æ‰‹æœºç«¯æ˜¯å¦è§¦å‘å¼€ç«

        // DOMå…ƒç´ ç¼“å­˜
        const DOM = {
            startScreen: document.getElementById('startScreen'),
            howToScreen: document.getElementById('howToScreen'),
            gameOverScreen: document.getElementById('gameOverScreen'),
            hud: document.getElementById('hud'),
            powerupHint: document.getElementById('powerupHint'),
            healthText: document.getElementById('health'),
            scoreText: document.getElementById('score'),
            finalScoreText: document.getElementById('finalScore'),
            startBtn: document.getElementById('startBtn'),
            howToBtn: document.getElementById('howToBtn'),
            backBtn: document.getElementById('backBtn'),
            restartBtn: document.getElementById('restartBtn'),
            quitBtn: document.getElementById('quitBtn'),
            fireBtn: document.getElementById('fireBtn'),
            joystick: document.getElementById('joystick'),
            joystickContainer: document.querySelector('.joystick-container')
        };

        // åˆå§‹åŒ–æ¸¸æˆï¼ˆé¡µé¢åŠ è½½å®Œæˆåæ‰§è¡Œï¼‰
        window.addEventListener('load', initGame);

        /**
         * åˆå§‹åŒ–æ¸¸æˆï¼šç»‘å®šäº‹ä»¶ã€è®¾ç½®ç”»å¸ƒã€å¯åŠ¨æ¸¸æˆå¾ªç¯
         */
        function initGame() {
            // è·å–ç”»å¸ƒå’Œä¸Šä¸‹æ–‡
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

            // åˆå§‹åŒ–ç”»å¸ƒå°ºå¯¸ï¼ˆé€‚é…å®¹å™¨ï¼‰
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // ç»‘å®šæ‰€æœ‰äº¤äº’äº‹ä»¶
            bindAllEvents();

            // å¯åŠ¨æ¸¸æˆå¾ªç¯ï¼ˆ60å¸§/ç§’ï¼‰
            setInterval(gameLoop, 16.67);
        }

        /**
         * è°ƒæ•´ç”»å¸ƒå°ºå¯¸ï¼ˆé€‚é…æ¸¸æˆå®¹å™¨ï¼‰
         */
        function resizeCanvas() {
            const container = document.querySelector('.game-container');
            canvas.width = container.offsetWidth;
            canvas.height = container.offsetHeight;

            // å¦‚æœæ¸¸æˆå·²å¼€å§‹ï¼Œé‡æ–°è°ƒæ•´ç©å®¶ä½ç½®ï¼ˆé¿å…è¶…å‡ºå±å¹•ï¼‰
            if (player && gameState === 'playing') {
                player.x = canvas.width / 2 - GAME_CONFIG.tankSize / 2;
                player.y = canvas.height - 80; // åº•éƒ¨ç•™å‡ºæ§åˆ¶åŒºç©ºé—´
            }
        }

        /**
         * ç»‘å®šæ‰€æœ‰äº¤äº’äº‹ä»¶ï¼ˆé”®ç›˜+è§¦æ‘¸+æŒ‰é’®ï¼‰
         */
        function bindAllEvents() {
            // é”®ç›˜æ§åˆ¶ï¼ˆç”µè„‘ç«¯ï¼‰
            bindKeyboardEvents();

            // è§¦æ‘¸æ§åˆ¶ï¼ˆæ‰‹æœºç«¯ï¼‰
            bindTouchEvents();

            // æŒ‰é’®æ§åˆ¶ï¼ˆæ‰€æœ‰è®¾å¤‡ï¼‰
            bindButtonEvents();
        }

        /**
         * ç»‘å®šé”®ç›˜äº‹ä»¶ï¼ˆç”µè„‘ç«¯æ“ä½œï¼‰
         */
        function bindKeyboardEvents() {
            // é”®ç›˜æŒ‰ä¸‹
            window.addEventListener('keydown', (e) => {
                if (gameState !== 'playing') return;

                switch(e.key.toLowerCase()) {
                    case 'w':
                    case 'arrowup':
                        keyState.up = true;
                        break;
                    case 's':
                    case 'arrowdown':
                        keyState.down = true;
                        break;
                    case 'a':
                    case 'arrowleft':
                        keyState.left = true;
                        break;
                    case 'd':
                    case 'arrowright':
                        keyState.right = true;
                        break;
                    case ' ':
                        keyState.fire = true;
                        break;
                }
            });

            // é”®ç›˜æ¾å¼€
            window.addEventListener('keyup', (e) => {
                switch(e.key.toLowerCase()) {
                    case 'w':
                    case 'arrowup':
                        keyState.up = false;
                        break;
                    case 's':
                    case 'arrowdown':
                        keyState.down = false;
                        break;
                    case 'a':
                    case 'arrowleft':
                        keyState.left = false;
                        break;
                    case 'd':
                    case 'arrowright':
                        keyState.right = false;
                        break;
                    case ' ':
                        keyState.fire = false;
                        break;
                }
            });
        }

        /**
         * ç»‘å®šè§¦æ‘¸äº‹ä»¶ï¼ˆæ‰‹æœºç«¯æ ¸å¿ƒæ“ä½œï¼‰
         */
        function bindTouchEvents() {
            const joystickEl = DOM.joystick;
            const joystickContainerEl = DOM.joystickContainer;
            const fireBtnEl = DOM.fireBtn;

            // æ‘‡æ†è§¦æ‘¸å¼€å§‹ï¼ˆæŒ‰ä¸‹æ‘‡æ†ï¼‰
            joystickContainerEl.addEventListener('touchstart', (e) => {
                e.preventDefault(); // é˜»æ­¢é¡µé¢æ»šåŠ¨ã€ç¼©æ”¾ç­‰é»˜è®¤è¡Œä¸ºï¼ˆé˜²è¯¯è§¦å…³é”®ï¼‰
                if (gameState !== 'playing') return;

                // è·å–ç¬¬ä¸€ä¸ªè§¦æ‘¸ç‚¹
                const touch = e.touches[0];
                const containerRect = joystickContainerEl.getBoundingClientRect();

                // è®°å½•æ‘‡æ†åŸºå‡†ç‚¹ï¼ˆå®¹å™¨ä¸­å¿ƒï¼‰
                joystickState.baseX = containerRect.left + containerRect.width / 2;
                joystickState.baseY = containerRect.top + containerRect.height / 2;

                // è®¡ç®—æ‘‡æ†åˆå§‹åç§»
                joystickState.x = touch.clientX - joystickState.baseX;
                joystickState.y = touch.clientY - joystickState.baseY;

                // æ ‡è®°æ‘‡æ†ä¸ºæ¿€æ´»çŠ¶æ€
                joystickState.active = true;

                // æ›´æ–°æ‘‡æ†è§†è§‰ä½ç½®
                updateJoystickVisual();
            }, { passive: false }); // passive: false å…è®¸è°ƒç”¨preventDefault

            // è§¦æ‘¸ç§»åŠ¨ï¼ˆæ‹–åŠ¨æ‘‡æ†ï¼‰
            window.addEventListener('touchmove', (e) => {
                if (!joystickState.active || gameState !== 'playing') return;

                e.preventDefault();
                const touch = e.touches[0];

                // æ›´æ–°æ‘‡æ†åç§»é‡
                joystickState.x = touch.clientX - joystickState.baseX;
                joystickState.y = touch.clientY - joystickState.baseY;

                // é™åˆ¶æ‘‡æ†æ´»åŠ¨èŒƒå›´ï¼ˆä¸è¶…å‡ºå®¹å™¨ï¼‰
                const maxRange = (joystickContainerEl.offsetWidth / 2) - 8;
                const distance = Math.sqrt(joystickState.x ** 2 + joystickState.y ** 2);

                if (distance > maxRange) {
                    const scaleRatio = maxRange / distance;
                    joystickState.x *= scaleRatio;
                    joystickState.y *= scaleRatio;
                }

                // æ›´æ–°æ‘‡æ†è§†è§‰ä½ç½®
                updateJoystickVisual();
            }, { passive: false });

            // è§¦æ‘¸ç»“æŸï¼ˆæ¾å¼€æ‘‡æ†/å±å¹•ï¼‰
            window.addEventListener('touchend', (e) => {
                // æ£€æŸ¥æ˜¯å¦æ¾å¼€çš„æ˜¯å¼€ç«æŒ‰é’®
                const touch = e.changedTouches[0];
                const fireBtnRect = fireBtnEl.getBoundingClientRect();
                const isFireBtnTouched = (
                    touch.clientX >= fireBtnRect.left &&
                    touch.clientX <= fireBtnRect.right &&
                    touch.clientY >= fireBtnRect.top &&
                    touch.clientY <= fireBtnRect.bottom
                );

                // å¦‚æœä¸æ˜¯æ¾å¼€å¼€ç«æŒ‰é’®ï¼Œé‡ç½®å¼€ç«çŠ¶æ€
                if (!isFireBtnTouched) {
                    isMobileFire = false;
                }

                // é‡ç½®æ‘‡æ†çŠ¶æ€
                if (joystickState.active) {
                    joystickState.active = false;
                    joystickState.x = 0;
                    joystickState.y = 0;
                    updateJoystickVisual();
                }
            }, { passive: false });

            // å¼€ç«æŒ‰é’®è§¦æ‘¸å¼€å§‹ï¼ˆæŒ‰ä¸‹å¼€ç«ï¼‰
            fireBtnEl.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation(); // é˜²æ­¢è§¦å‘æ‘‡æ†äº‹ä»¶
                if (gameState === 'playing') {
                    isMobileFire = true;
                }
            }, { passive: false });

            // å¼€ç«æŒ‰é’®è§¦æ‘¸ç»“æŸï¼ˆæ¾å¼€å¼€ç«ï¼‰
            fireBtnEl.addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                isMobileFire = false;
            }, { passive: false });

            // å¼€ç«æŒ‰é’®è§¦æ‘¸å–æ¶ˆï¼ˆæ„å¤–ç¦»å¼€å±å¹•ï¼‰
            fireBtnEl.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                e.stopPropagation();
                isMobileFire = false;
            }, { passive: false });
        }

        /**
         * ç»‘å®šæŒ‰é’®äº‹ä»¶ï¼ˆå¼€å§‹ã€è¯´æ˜ã€é‡å¯ç­‰ï¼‰
         */
        function bindButtonEvents() {
            // å¼€å§‹æ¸¸æˆ
            DOM.startBtn.addEventListener('click', () => {
                startGame();
            });

            // æ˜¾ç¤ºæ¸¸æˆè¯´æ˜
            DOM.howToBtn.addEventListener('click', () => {
                DOM.startScreen.style.display = 'none';
                DOM.howToScreen.style.display = 'flex';
            });

            // è¿”å›å¼€å§‹ç•Œé¢
            DOM.backBtn.addEventListener('click', () => {
                DOM.howToScreen.style.display = 'none';
                DOM.startScreen.style.display = 'flex';
            });

            // é‡æ–°å¼€å§‹æ¸¸æˆ
            DOM.restartBtn.addEventListener('click', () => {
                startGame();
            });

            // é€€å‡ºæ¸¸æˆï¼ˆè¿”å›å¼€å§‹ç•Œé¢ï¼‰
            DOM.quitBtn.addEventListener('click', () => {
                gameState = 'start';
                DOM.gameOverScreen.style.display = 'none';
                DOM.startScreen.style.display = 'flex';
                DOM.hud.style.display = 'none';
                DOM.powerupHint.style.display = 'none';
            });
        }

        /**
         * æ›´æ–°æ‘‡æ†è§†è§‰ä½ç½®
         */
        function updateJoystickVisual() {
            DOM.joystick.style.transform = `translate(${joystickState.x}px, ${joystickState.y}px)`;
        }

        /**
         * å¼€å§‹æ¸¸æˆï¼ˆé‡ç½®çŠ¶æ€+åˆå§‹åŒ–æ¸¸æˆå…ƒç´ ï¼‰
         */
        function startGame() {
            // é‡ç½®æ¸¸æˆçŠ¶æ€
            gameState = 'playing';
            score = 0;
            enemySpawnTimer = 0;
            powerUpSpawnTimer = 0;
            enemies = [];
            bullets = [];
            obstacles = [];
            powerUps = [];

            // åˆå§‹åŒ–ç©å®¶å¦å…‹ï¼ˆåº•éƒ¨å±…ä¸­ä½ç½®ï¼‰
            player = {
                x: canvas.width / 2 - GAME_CONFIG.tankSize / 2,
                y: canvas.height - 80,
                size: GAME_CONFIG.tankSize,
                speed: GAME_CONFIG.playerSpeed,
                direction: 'up', // åˆå§‹æœå‘
                health: GAME_CONFIG.playerMaxHealth,
                fireCooldown: 0, // å‘å°„å†·å´ï¼ˆæ¯«ç§’ï¼‰
                powerUp: null, // å½“å‰é“å…·æ•ˆæœï¼ˆnull: æ— æ•ˆæœï¼‰
                powerUpTimer: 0 // é“å…·æ•ˆæœå‰©ä½™æ—¶é—´
            };

            // ç”Ÿæˆåˆå§‹éšœç¢ç‰©ï¼ˆéšæœºåˆ†å¸ƒï¼Œä¸é®æŒ¡ç©å®¶ï¼‰
            generateObstacles();

            // æ›´æ–°UIæ˜¾ç¤º
            DOM.startScreen.style.display = 'none';
            DOM.gameOverScreen.style.display = 'none';
            DOM.hud.style.display = 'flex';
            DOM.powerupHint.style.display = 'none';
            DOM.healthText.textContent = player.health;
            DOM.scoreText.textContent = score;
            DOM.finalScoreText.textContent = score;
        }

        /**
         * ç”Ÿæˆéšæœºéšœç¢ç‰©ï¼ˆé¿å…ä¸ç©å®¶åˆå§‹ä½ç½®é‡å ï¼‰
         */
        function generateObstacles() {
            const obstacleCount = 12; // éšœç¢ç‰©æ•°é‡ï¼ˆ12ä¸ªï¼Œé€‚ä¸­ï¼‰
            const rows = Math.floor(canvas.height / GAME_CONFIG.obstacleSize);
            const cols = Math.floor(canvas.width / GAME_CONFIG.obstacleSize);

            for (let i = 0; i < obstacleCount; i++) {
                let x, y;
                let isPositionValid = false;

                // å¾ªç¯ç›´åˆ°æ‰¾åˆ°åˆæ³•ä½ç½®ï¼ˆä¸ä¸ç©å®¶åˆå§‹ä½ç½®é‡å ï¼‰
                while (!isPositionValid) {
                    // éšæœºç”Ÿæˆç½‘æ ¼ä½ç½®
                    x = Math.floor(Math.random() * cols) * GAME_CONFIG.obstacleSize;
                    y = Math.floor(Math.random() * rows) * GAME_CONFIG.obstacleSize;

                    // ç©å®¶åˆå§‹ä½ç½®åŒºåŸŸï¼ˆåº•éƒ¨å±…ä¸­ï¼‰
                    const playerSafeArea = {
                        x: canvas.width / 2 - GAME_CONFIG.tankSize * 2,
                        y: canvas.height - 120,
                        width: GAME_CONFIG.tankSize * 4,
                        height: 100
                    };

                    // æ£€æŸ¥æ˜¯å¦é‡å 
                    const isOverlap = (
                        x < playerSafeArea.x + playerSafeArea.width &&
                        x + GAME_CONFIG.obstacleSize > playerSafeArea.x &&
                        y < playerSafeArea.y + playerSafeArea.height &&
                        y + GAME_CONFIG.obstacleSize > playerSafeArea.y
                    );

                    if (!isOverlap) {
                        isPositionValid = true;
                    }
                }

                // æ·»åŠ éšœç¢ç‰©ï¼ˆ70%ç –å—ï¼ˆå¯æ‘§æ¯ï¼‰ï¼Œ30%é’¢é“ï¼ˆä¸å¯æ‘§æ¯ï¼‰ï¼‰
                obstacles.push({
                    x,
                    y,
                    width: GAME_CONFIG.obstacleSize,
                    height: GAME_CONFIG.obstacleSize,
                    type: Math.random() > 0.3 ? 'brick' : 'steel'
                });
            }
        }

        /**
         * ç”Ÿæˆæ•Œäººå¦å…‹ï¼ˆé¡¶éƒ¨éšæœºä½ç½®ï¼‰
         */
        function spawnEnemy() {
            if (enemies.length >= GAME_CONFIG.maxEnemies) return;

            // æ•Œäººç”ŸæˆåŒºåŸŸï¼ˆé¡¶éƒ¨1/3å±å¹•ï¼Œé¿å…è¾¹ç¼˜ï¼‰
            const spawnX = Math.random() * (canvas.width - GAME_CONFIG.tankSize - 40) + 20;
            const spawnY = Math.random() * (canvas.height / 3 - 40) + 20;

            // æ·»åŠ æ•Œäºº
            enemies.push({
                x: spawnX,
                y: spawnY,
                size: GAME_CONFIG.tankSize,
                speed: GAME_CONFIG.enemySpeed,
                direction: 'down', // åˆå§‹æœå‘ï¼ˆå‘ä¸‹ï¼‰
                fireCooldown: 0,
                lastFireTime: Date.now(),
                fireRate: 2500 + Math.random() * 3000 // éšæœºå‘å°„é—´éš”ï¼ˆ2.5-5.5ç§’ï¼‰
            });
        }

        /**
         * ç”Ÿæˆé“å…·ï¼ˆéšæœºä½ç½®ï¼Œä¸¤ç§ç±»å‹ï¼‰
         */
        function spawnPowerUp() {
            // é“å…·ç±»å‹ï¼šspeedï¼ˆåŠ é€Ÿï¼‰ã€healï¼ˆå›è¡€ï¼‰
            const powerUpTypes = ['speed', 'heal'];
            const randomType = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];

            // é“å…·ç”Ÿæˆä½ç½®ï¼ˆé¿å…è¾¹ç¼˜å’Œéšœç¢ç‰©ï¼‰
            const x = Math.random() * (canvas.width - GAME_CONFIG.powerUpSize - 40) + 20;
            const y = Math.random() * (canvas.height - GAME_CONFIG.powerUpSize - 40) + 20;

            // æ£€æŸ¥æ˜¯å¦ä¸éšœç¢ç‰©é‡å ï¼ˆé¿å…é“å…·è¢«æŒ¡ä½ï¼‰
            const isOverlapWithObstacle = obstacles.some(obstacle => {
                return checkCollision(
                    { x, y, width: GAME_CONFIG.powerUpSize, height: GAME_CONFIG.powerUpSize },
                    { x: obstacle.x, y: obstacle.y, width: obstacle.width, height: obstacle.height }
                );
            });

            if (!isOverlapWithObstacle) {
                powerUps.push({
                    x,
                    y,
                    size: GAME_CONFIG.powerUpSize,
                    type: randomType,
                    spawnTime: Date.now()
                });
            }
        }

        /**
         * å‘å°„å­å¼¹
         * @param {Object} shooter - å‘å°„è€…ï¼ˆç©å®¶/æ•Œäººï¼‰
         * @param {boolean} isEnemy - æ˜¯å¦æ˜¯æ•Œäººå‘å°„
         */
        function fireBullet(shooter, isEnemy = false) {
            // è®¡ç®—å­å¼¹åˆå§‹ä½ç½®ï¼ˆå¦å…‹ä¸­å¿ƒï¼Œæœå‘æ–¹å‘ï¼‰
            let bulletX, bulletY;
            const tankCenterX = shooter.x + shooter.size / 2;
            const tankCenterY = shooter.y + shooter.size / 2;

            switch(shooter.direction) {
                case 'up':
                    bulletX = tankCenterX - GAME_CONFIG.bulletSize / 2;
                    bulletY = shooter.y - GAME_CONFIG.bulletSize;
                    break;
                case 'down':
                    bulletX = tankCenterX - GAME_CONFIG.bulletSize / 2;
                    bulletY = shooter.y + shooter.size;
                    break;
                case 'left':
                    bulletX = shooter.x - GAME_CONFIG.bulletSize;
                    bulletY = tankCenterY - GAME_CONFIG.bulletSize / 2;
                    break;
                case 'right':
                    bulletX = shooter.x + shooter.size;
                    bulletY = tankCenterY - GAME_CONFIG.bulletSize / 2;
                    break;
            }

            // æ·»åŠ å­å¼¹åˆ°æ•°ç»„
            bullets.push({
                x: bulletX,
                y: bulletY,
                width: GAME_CONFIG.bulletSize,
                height: GAME_CONFIG.bulletSize,
                direction: shooter.direction,
                speed: GAME_CONFIG.bulletSpeed,
                isEnemy,
                spawnTime: Date.now()
            });
        }

        /**
         * æ£€æµ‹ä¸¤ä¸ªçŸ©å½¢æ˜¯å¦ç¢°æ’
         * @param {Object} rectA - çŸ©å½¢A {x, y, width, height}
         * @param {Object} rectB - çŸ©å½¢B {x, y, width, height}
         * @returns {boolean} æ˜¯å¦ç¢°æ’
         */
        function checkCollision(rectA, rectB) {
            return (
                rectA.x < rectB.x + rectB.width &&
                rectA.x + rectA.width > rectB.x &&
                rectA.y < rectB.y + rectB.height &&
                rectA.y + rectA.height > rectB.y
            );
        }

        /**
         * æ›´æ–°ç©å®¶çŠ¶æ€ï¼ˆç§»åŠ¨+å¼€ç«+é“å…·æ•ˆæœï¼‰
         * @param {number} deltaTime - æ—¶é—´å·®ï¼ˆæ¯«ç§’ï¼‰
         */
        function updatePlayer(deltaTime) {
            if (!player) return;

            let moveX = 0;
            let moveY = 0;

            // 1. å¤„ç†ç§»åŠ¨ï¼ˆé”®ç›˜+æ‘‡æ†ä¼˜å…ˆçº§ï¼šæ‘‡æ† > é”®ç›˜ï¼‰
            if (joystickState.active) {
                // æ‘‡æ†æ§åˆ¶ï¼šæ ¹æ®åç§»é‡è®¡ç®—ç§»åŠ¨æ–¹å‘å’Œé€Ÿåº¦
                const angle = Math.atan2(joystickState.y, joystickState.x);
                const speed = player.speed;

                if (Math.abs(joystickState.x) > Math.abs(joystickState.y)) {
                    // æ°´å¹³ç§»åŠ¨ï¼ˆå·¦å³ï¼‰
                    moveX = Math.cos(angle) * speed;
                    player.direction = moveX > 0 ? 'right' : 'left';
                } else {
                    // å‚ç›´ç§»åŠ¨ï¼ˆä¸Šä¸‹ï¼‰
                    moveY = Math.sin(angle) * speed;
                    player.direction = moveY > 0 ? 'down' : 'up';
                }
            } else {
                // é”®ç›˜æ§åˆ¶
                if (keyState.up) {
                    moveY = -player.speed;
                    player.direction = 'up';
                }
                if (keyState.down) {
                    moveY = player.speed;
                    player.direction = 'down';
                }
                if (keyState.left) {
                    moveX = -player.speed;
                    player.direction = 'left';
                }
                if (keyState.right) {
                    moveX = player.speed;
                    player.direction = 'right';
                }
            }

            // 2. è¾¹ç•Œæ£€æµ‹ï¼ˆé¿å…ç©å®¶è¶…å‡ºå±å¹•ï¼‰
            const newX = player.x + moveX;
            const newY = player.y + moveY;

            if (newX >= 0 && newX + player.size <= canvas.width) {
                player.x = newX;
            }
            if (newY >= 0 && newY + player.size <= canvas.height) {
                player.y = newY;
            }

            // 3. éšœç¢ç‰©ç¢°æ’æ£€æµ‹ï¼ˆé¿å…ç©¿è¿‡éšœç¢ç‰©ï¼‰
            const playerRect = {
                x: player.x,
                y: player.y,
                width: player.size,
                height: player.size
            };

            obstacles.forEach(obstacle => {
                const obstacleRect = {
                    x: obstacle.x,
                    y: obstacle.y,
                    width: obstacle.width,
                    height: obstacle.height
                };

                if (checkCollision(playerRect, obstacleRect)) {
                    // ç¢°æ’åæ¨å›ç©å®¶ï¼ˆæ ¹æ®ç§»åŠ¨æ–¹å‘ï¼‰
                    switch(player.direction) {
                        case 'up':
                            player.y = obstacle.y + obstacle.height;
                            break;
                        case 'down':
                            player.y = obstacle.y - player.size;
                            break;
                        case 'left':
                            player.x = obstacle.x + obstacle.width;
                            break;
                        case 'right':
                            player.x = obstacle.x - player.size;
                            break;
                    }
                }
            });

            // 4. é“å…·æ•ˆæœæ›´æ–°
            if (player.powerUp) {
                player.powerUpTimer -= deltaTime;

                if (player.powerUpTimer <= 0) {
                    // é“å…·æ•ˆæœç»“æŸï¼Œé‡ç½®çŠ¶æ€
                    if (player.powerUp === 'speed') {
                        player.speed = GAME_CONFIG.playerSpeed;
                        DOM.powerupHint.style.display = 'none';
                    }
                    player.powerUp = null;
                }
            }

            // 5. å¼€ç«æ§åˆ¶ï¼ˆå†·å´æ—¶é—´+è§¦å‘æ¡ä»¶ï¼‰
            player.fireCooldown -= deltaTime;
            const isFireTriggered = keyState.fire || isMobileFire;

            if (isFireTriggered && player.fireCooldown <= 0) {
                fireBullet(player, false);
                player.fireCooldown = 500; // 500æ¯«ç§’å†·å´ï¼ˆæ¯ç§’2å‘ï¼‰
            }
        }

        /**
         * æ›´æ–°æ•ŒäººçŠ¶æ€ï¼ˆç§»åŠ¨+å¼€ç«+AIï¼‰
         * @param {number} deltaTime - æ—¶é—´å·®ï¼ˆæ¯«ç§’ï¼‰
         */
        function updateEnemies(deltaTime) {
            enemies.forEach(enemy => {
                let moveX = 0;
                let moveY = 0;

                // 1. ç®€å•AIï¼šéšæœºè½¬å‘ï¼ˆæ¯å¸§æœ‰0.8%æ¦‚ç‡è½¬å‘ï¼‰
                if (Math.random() < 0.008) {
                    const directions = ['up', 'down', 'left', 'right'];
                    enemy.direction = directions[Math.floor(Math.random() * directions.length)];
                }

                // 2. æ ¹æ®æ–¹å‘ç§»åŠ¨
                switch(enemy.direction) {
                    case 'up':
                        moveY = -enemy.speed;
                        break;
                    case 'down':
                        moveY = enemy.speed;
                        break;
                    case 'left':
                        moveX = -enemy.speed;
                        break;
                    case 'right':
                        moveX = enemy.speed;
                        break;
                }

                // 3. è¾¹ç•Œæ£€æµ‹+åå¼¹ï¼ˆç¢°åˆ°è¾¹ç•Œè½¬å‘ï¼‰
                const newX = enemy.x + moveX;
                const newY = enemy.y + moveY;

                if (newX >= 0 && newX + enemy.size <= canvas.width) {
                    enemy.x = newX;
                } else {
                    enemy.direction = enemy.direction === 'left' ? 'right' : 'left';
                }

                if (newY >= 0 && newY + enemy.size <= canvas.height) {
                    enemy.y = newY;
                } else {
                    enemy.direction = enemy.direction === 'up' ? 'down' : 'up';
                }

                // 4. éšœç¢ç‰©ç¢°æ’æ£€æµ‹+è½¬å‘
                const enemyRect = {
                    x: enemy.x,
                    y: enemy.y,
                    width: enemy.size,
                    height: enemy.size
                };

                obstacles.forEach(obstacle => {
                    const obstacleRect = {
                        x: obstacle.x,
                        y: obstacle.y,
                        width: obstacle.width,
                        height: obstacle.height
                    };

                    if (checkCollision(enemyRect, obstacleRect)) {
                        // ç¢°æ’åéšæœºè½¬å‘
                        const directions = ['up', 'down', 'left', 'right'];
                        enemy.direction = directions[Math.floor(Math.random() * directions.length)];
                    }
                });

                // 5. æ•Œäººå¼€ç«ï¼ˆéšæœºé—´éš”ï¼‰
                const currentTime = Date.now();
                if (currentTime - enemy.lastFireTime >= enemy.fireRate) {
                    fireBullet(enemy, true);
                    enemy.lastFireTime = currentTime;
                }
            });
        }

        /**
         * æ›´æ–°å­å¼¹çŠ¶æ€ï¼ˆç§»åŠ¨+ç¢°æ’æ£€æµ‹+è¶…æ—¶åˆ é™¤ï¼‰
         */
        function updateBullets() {
            // å€’åºéå†ï¼šé¿å…åˆ é™¤å…ƒç´ æ—¶ç´¢å¼•é”™ä¹±
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];

                // 1. ç§»åŠ¨å­å¼¹
                switch(bullet.direction) {
                    case 'up':
                        bullet.y -= bullet.speed;
                        break;
                    case 'down':
                        bullet.y += bullet.speed;
                        break;
                    case 'left':
                        bullet.x -= bullet.speed;
                        break;
                    case 'right':
                        bullet.x += bullet.speed;
                        break;
                }

                // 2. è¶…å‡ºå±å¹•åˆ é™¤
                if (
                    bullet.x < -bullet.width ||
                    bullet.x > canvas.width ||
                    bullet.y < -bullet.height ||
                    bullet.y > canvas.height
                ) {
                    bullets.splice(i, 1);
                    continue;
                }

                // 3. å­å¼¹è¶…æ—¶åˆ é™¤ï¼ˆ3ç§’æœªå‘½ä¸­è‡ªåŠ¨æ¶ˆå¤±ï¼‰
                if (Date.now() - bullet.spawnTime > 3000) {
                    bullets.splice(i, 1);
                    continue;
                }

                // 4. å­å¼¹ç¢°æ’æ£€æµ‹
                const bulletRect = {
                    x: bullet.x,
                    y: bullet.y,
                    width: bullet.width,
                    height: bullet.height
                };

                // 4.1 å­å¼¹ç¢°æ’éšœç¢ç‰©
                let hitObstacle = false;
                for (let j = obstacles.length - 1; j >= 0; j--) {
                    const obstacle = obstacles[j];
                    const obstacleRect = {
                        x: obstacle.x,
                        y: obstacle.y,
                        width: obstacle.width,
                        height: obstacle.height
                    };

                    if (checkCollision(bulletRect, obstacleRect)) {
                        // å­å¼¹åˆ é™¤
                        bullets.splice(i, 1);
                        hitObstacle = true;

                        // ç –å—éšœç¢ç‰©å¯æ‘§æ¯ï¼Œé’¢é“ä¸å¯æ‘§æ¯
                        if (obstacle.type === 'brick') {
                            obstacles.splice(j, 1);
                        }
                        break;
                    }
                }

                if (hitObstacle) continue;

                // 4.2 ç©å®¶å­å¼¹ç¢°æ’æ•Œäºº
                if (!bullet.isEnemy) {
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const enemy = enemies[j];
                        const enemyRect = {
                            x: enemy.x,
                            y: enemy.y,
                            width: enemy.size,
                            height: enemy.size
                        };

                        if (checkCollision(bulletRect, enemyRect)) {
                            // å­å¼¹+æ•Œäººåˆ é™¤
                            bullets.splice(i, 1);
                            enemies.splice(j, 1);

                            // åŠ åˆ†ï¼ˆ100åˆ†/ä¸ªï¼‰
                            score += 100;
                            DOM.scoreText.textContent = score;
                            break;
                        }
                    }
                }
                // 4.3 æ•Œäººå­å¼¹ç¢°æ’ç©å®¶
                else {
                    if (player) {
                        const playerRect = {
                            x: player.x,
                            y: player.y,
                            width: player.size,
                            height: player.size
                        };

                        if (checkCollision(bulletRect, playerRect)) {
                            // å­å¼¹åˆ é™¤
                            bullets.splice(i, 1);

                            // ç©å®¶å‡è¡€
                            player.health--;
                            DOM.healthText.textContent = player.health;

                            // ç”Ÿå‘½å€¼ä¸º0ï¼Œæ¸¸æˆç»“æŸ
                            if (player.health <= 0) {
                                gameOver();
                            }
                        }
                    }
                }
            }
        }

        /**
         * æ›´æ–°é“å…·çŠ¶æ€ï¼ˆç¢°æ’æ£€æµ‹+è¶…æ—¶åˆ é™¤ï¼‰
         */
        function updatePowerUps() {
            // å€’åºéå†
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const powerUp = powerUps[i];

                // 1. é“å…·è¶…æ—¶åˆ é™¤ï¼ˆ10ç§’æœªæ‹¾å–ï¼‰
                if (Date.now() - powerUp.spawnTime > 10000) {
                    powerUps.splice(i, 1);
                    continue;
                }

                // 2. ç©å®¶ç¢°æ’é“å…·ï¼ˆæ‹¾å–ï¼‰
                if (player) {
                    const powerUpRect = {
                        x: powerUp.x,
                        y: powerUp.y,
                        width: powerUp.size,
                        height: powerUp.size
                    };

                    const playerRect = {
                        x: player.x,
                        y: player.y,
                        width: player.size,
                        height: player.size
                    };

                    if (checkCollision(powerUpRect, playerRect)) {
                        // åº”ç”¨é“å…·æ•ˆæœ
                        switch(powerUp.type) {
                            case 'speed':
                                player.powerUp = 'speed';
                                player.powerUpTimer = GAME_CONFIG.powerUpDuration;
                                player.speed = GAME_CONFIG.playerSpeed * 1.8; // åŠ é€Ÿ1.8å€
                                DOM.powerupHint.style.display = 'block';
                                break;
                            case 'heal':
                                // å›è¡€ä¸è¶…è¿‡æœ€å¤§ç”Ÿå‘½å€¼
                                if (player.health < GAME_CONFIG.playerMaxHealth) {
                                    player.health++;
                                    DOM.healthText.textContent = player.health;
                                }
                                break;
                        }

                        // é“å…·åˆ é™¤
                        powerUps.splice(i, 1);
                    }
                }
            }
        }

        /**
         * æ¸¸æˆç»“æŸ
         */
        function gameOver() {
            gameState = 'gameOver';
            DOM.gameOverScreen.style.display = 'flex';
            DOM.hud.style.display = 'none';
            DOM.powerupHint.style.display = 'none';
            DOM.finalScoreText.textContent = score;
        }

        /**
         * ç»˜åˆ¶æ¸¸æˆå…ƒç´ ï¼ˆå¦å…‹+å­å¼¹+éšœç¢ç‰©+é“å…·ï¼‰
         */
        function renderGame() {
            // 1. æ¸…ç©ºç”»å¸ƒï¼ˆé»‘è‰²èƒŒæ™¯ï¼‰
            ctx.fillStyle = '#111827';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 2. ç»˜åˆ¶ç½‘æ ¼èƒŒæ™¯ï¼ˆæå‡è§†è§‰æ•ˆæœï¼‰
            drawGrid();

            // 3. ç»˜åˆ¶éšœç¢ç‰©
            drawObstacles();

            // 4. ç»˜åˆ¶é“å…·
            drawPowerUps();

            // 5. ç»˜åˆ¶å­å¼¹
            drawBullets();

            // 6. ç»˜åˆ¶ç©å®¶å¦å…‹
            if (player) {
                drawTank(player, 'player');
            }

            // 7. ç»˜åˆ¶æ•Œäººå¦å…‹
            enemies.forEach(enemy => {
                drawTank(enemy, 'enemy');
            });
        }

        /**
         * ç»˜åˆ¶ç½‘æ ¼èƒŒæ™¯
         */
        function drawGrid() {
            ctx.strokeStyle = '#1f2937'; // ç½‘æ ¼é¢œè‰²ï¼ˆæ·±ç°è‰²ï¼Œä¸çªå…€ï¼‰
            ctx.lineWidth = 1;

            const gridSize = 32; // ç½‘æ ¼å¤§å°ï¼ˆä¸å¦å…‹/éšœç¢ç‰©å°ºå¯¸ä¸€è‡´ï¼‰

            // ç»˜åˆ¶æ°´å¹³çº¿
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // ç»˜åˆ¶å‚ç›´çº¿
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
        }

        /**
         * ç»˜åˆ¶éšœç¢ç‰©
         */
        function drawObstacles() {
            obstacles.forEach(obstacle => {
                if (obstacle.type === 'brick') {
                    // ç –å—éšœç¢ç‰©ï¼ˆç°è‰²+çº¹ç†ï¼‰
                    ctx.fillStyle = '#78716C';
                    ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);

                    // ç –å—çº¹ç†ï¼ˆæ·±è‰²ä¸­å¿ƒï¼‰
                    ctx.fillStyle = '#57534E';
                    ctx.fillRect(
                        obstacle.x + 4,
                        obstacle.y + 4,
                        obstacle.width - 8,
                        obstacle.height - 8
                    );
                } else {
                    // é’¢é“éšœç¢ç‰©ï¼ˆæµ…ç°è‰²+çº¹ç†ï¼‰
                    ctx.fillStyle = '#9CA3AF';
                    ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);

                    // é’¢é“çº¹ç†ï¼ˆæ·±è‰²ä¸­å¿ƒï¼‰
                    ctx.fillStyle = '#6B7280';
                    ctx.fillRect(
                        obstacle.x + 6,
                        obstacle.y + 6,
                        obstacle.width - 12,
                        obstacle.height - 12
                    );
                }

                // éšœç¢ç‰©è¾¹æ¡†ï¼ˆæ·±ç°è‰²ï¼‰
                ctx.strokeStyle = '#374151';
                ctx.lineWidth = 2;
                ctx.strokeRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
            });
        }

        /**
         * ç»˜åˆ¶é“å…·
         */
        function drawPowerUps() {
            powerUps.forEach(powerUp => {
                ctx.save();

                // é“å…·åœ†å½¢èƒŒæ™¯ï¼ˆå¸¦å‘å…‰æ•ˆæœï¼‰
                ctx.beginPath();
                ctx.arc(
                    powerUp.x + powerUp.size / 2,
                    powerUp.y + powerUp.size / 2,
                    powerUp.size / 2,
                    0,
                    Math.PI * 2
                );

                // æ ¹æ®ç±»å‹è®¾ç½®é¢œè‰²
                if (powerUp.type === 'speed') {
                    ctx.fillStyle = '#3B82F6'; // è“è‰²ï¼ˆåŠ é€Ÿï¼‰
                    ctx.shadowColor = '#3B82F6';
                } else {
                    ctx.fillStyle = '#10B981'; // ç»¿è‰²ï¼ˆå›è¡€ï¼‰
                    ctx.shadowColor = '#10B981';
                }

                ctx.shadowBlur = 15;
                ctx.fill();
                ctx.restore();

                // ç»˜åˆ¶é“å…·å›¾æ ‡ï¼ˆFontAwesomeï¼‰
                ctx.fillStyle = 'white';
                ctx.font = `bold ${powerUp.size / 1.5}px FontAwesome`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                const iconCode = powerUp.type === 'speed' ? 'ï¡' : 'ï€«';
                ctx.fillText(
                    iconCode,
                    powerUp.x + powerUp.size / 2,
                    powerUp.y + powerUp.size / 2
                );
            });
        }

        /**
         * ç»˜åˆ¶å­å¼¹
         */
        function drawBullets() {
            bullets.forEach(bullet => {
                ctx.save();

                // å­å¼¹ä¸»ä½“ï¼ˆæ©™è‰²+å‘å…‰ï¼‰
                ctx.fillStyle = '#F59E0B';
                ctx.shadowColor = '#F59E0B';
                ctx.shadowBlur = 8;
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);

                // å­å¼¹è¾¹æ¡†ï¼ˆæ·±æ©™è‰²ï¼‰
                ctx.strokeStyle = '#D97706';
                ctx.lineWidth = 2;
                ctx.strokeRect(bullet.x, bullet.y, bullet.width, bullet.height);

                // å­å¼¹é«˜å…‰ï¼ˆç™½è‰²åŠé€æ˜ï¼‰
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.fillRect(
                    bullet.x + 1,
                    bullet.y + 1,
                    bullet.width - 2,
                    bullet.height - 2
                );

                ctx.restore();
            });
        }

        /**
         * ç»˜åˆ¶å¦å…‹
         * @param {Object} tank - å¦å…‹æ•°æ®
         * @param {string} type - å¦å…‹ç±»å‹ï¼ˆplayer/enemyï¼‰
         */
        function drawTank(tank, type) {
            const centerX = tank.x + tank.size / 2;
            const centerY = tank.y + tank.size / 2;

            ctx.save();

            // 1. å¦å…‹ä¸»ä½“
            ctx.fillStyle = type === 'player' ? '#22C55E' : '#EF4444';
            ctx.fillRect(tank.x, tank.y, tank.size, tank.size);

            // 2. å¦å…‹é¡¶éƒ¨ï¼ˆæ·±è‰²ï¼‰
            ctx.fillStyle = type === 'player' ? '#16A34A' : '#DC2626';
            ctx.fillRect(
                tank.x + 4,
                tank.y + 4,
                tank.size - 8,
                tank.size - 8
            );

            // 3. å¦å…‹ç‚®å¡”ï¼ˆåœ†å½¢ï¼‰
            ctx.fillStyle = type === 'player' ? '#15803D' : '#B91C1C';
            ctx.beginPath();
            ctx.arc(centerX, centerY, tank.size / 4, 0, Math.PI * 2);
            ctx.fill();

            // 4. å¦å…‹ç‚®ç®¡
            ctx.strokeStyle = type === 'player' ? '#14532D' : '#991B1B';
            ctx.lineWidth = tank.size / 8;
            ctx.lineCap = 'round';
            ctx.beginPath();

            switch(tank.direction) {
                case 'up':
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(centerX, tank.y - tank.size / 4);
                    break;
                case 'down':
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(centerX, tank.y + tank.size + tank.size / 4);
                    break;
                case 'left':
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(tank.x - tank.size / 4, centerY);
                    break;
                case 'right':
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(tank.x + tank.size + tank.size / 4, centerY);
                    break;
            }

            ctx.stroke();

            // 5. å¦å…‹å±¥å¸¦ï¼ˆæ·±ç°è‰²ï¼‰
            ctx.fillStyle = '#4B5563';
            // å·¦å±¥å¸¦
            ctx.fillRect(tank.x - 4, tank.y, 4, tank.size);
            // å³å±¥å¸¦
            ctx.fillRect(tank.x + tank.size, tank.y, 4, tank.size);
            // ä¸Šå±¥å¸¦
            ctx.fillRect(tank.x, tank.y - 4, tank.size, 4);
            // ä¸‹å±¥å¸¦
            ctx.fillRect(tank.x, tank.y + tank.size, tank.size, 4);

            ctx.restore();
        }

        /**
         * æ¸¸æˆä¸»å¾ªç¯ï¼ˆæ¯å¸§æ‰§è¡Œï¼šæ›´æ–°çŠ¶æ€â†’ç»˜åˆ¶ç”»é¢ï¼‰
         */
        function gameLoop() {
            const deltaTime = 16.67; // æ¯å¸§æ—¶é—´å·®ï¼ˆæ¯«ç§’ï¼‰

            if (gameState === 'playing') {
                // 1. æ›´æ–°æ¸¸æˆçŠ¶æ€
                updatePlayer(deltaTime);
                updateEnemies(deltaTime);
                updateBullets();
                updatePowerUps();

                // 2. ç”Ÿæˆæ•Œäººï¼ˆè®¡æ—¶ï¼‰
                enemySpawnTimer += deltaTime;
                if (enemySpawnTimer >= GAME_CONFIG.enemySpawnInterval) {
                    spawnEnemy();
                    enemySpawnTimer = 0;
                }

                // 3. ç”Ÿæˆé“å…·ï¼ˆè®¡æ—¶ï¼‰
                powerUpSpawnTimer += deltaTime;
                if (powerUpSpawnTimer >= GAME_CONFIG.powerUpSpawnInterval) {
                    spawnPowerUp();
                    powerUpSpawnTimer = 0;
                }
            }

            // 4. ç»˜åˆ¶æ¸¸æˆç”»é¢ï¼ˆæ— è®ºä»€ä¹ˆçŠ¶æ€ï¼Œéƒ½éœ€è¦ç»˜åˆ¶èƒŒæ™¯ï¼‰
            renderGame();
        }
    </script>
</body>
</html>